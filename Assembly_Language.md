# Assembly Language Study

## x64 Registers

---

**레지스터의 종류**

---
| Register | Description |
| --- | --- |
| %rsp | 스택 포인터 레지스터, 메모리 Stack 의 Top 주소를 저장하고 있음 |
| %rbp | 스택 베이스 포인터 레지스터. 스택 Frame의 시작 주소를 저장하고 있음. 임의의 함수의 스택 베이스 주소를 저장하는 $rbp는 함수가 종료될 때까지 변하지 않는다고 함. |
| %rip | Instruction 포인터 레지스터. 다음 실행할 Instruction이 저장된 메모리 주소를 저장. |
| %rdi | 범용레지스터, 보통 함수 파라미터 값 저장에 사용 |
| %rsi | 범용레지스터, 보통 함수 파라미터 값 저장에 사용 |
| %rbx | 범용레지스터, 보통 함수 파라미터 값 저장에 사용 |
| %rcx | 범용레지스터, 보통 함수 파라미터 값 저장에 사용 |

**메모리 주소 지정모드**

---

레지스터는 메모리의 특정위치의 주소값을 저장하기 위해서 사용된다. 메모리에 접근할 때 사용되는 주소 지정 모드가 존재하는데, 

주소 지정 모드를 통해서 메모리 연산을 수행하고 메모리의 원하는 위치를 접근할 수 있게 된다.

일반 

D(R) → R: 레지스터를 의미, D: offset을 의미

Mem[Reg[R] + D] → Reg[R]: 레지스터 R에 저장된 값

(R) → 레지스터 R이 저장하고 있는 값에 해당하는 메모리 주소에 저장된 Value

예를 들면 R: 0x001 이라고 가정하고 메모리 0x001 번지에는 0xFF 라는 값이 저장되어 있다고 가정한다. 

(R)은 메모리에서 0x001 주소를 찾아가서 해당 값을 가져오는 것이다. 따라서 현재 메모리 0x001 번지에는 0xFF 값이 존재하므로

(R) 은 0xFF가 된다.

Mem[Reg[R]] ⇒ Mem[0x01] = 0xFF  
  
  
  
## Memory Stack Frame
---

**Memory Heirarchy**

---

**Memory Heirarchy** 
| Segment | Value |  |
| --- | --- | --- |
| Code | 함수, 제어문, 상수영역 | CompileTime에 크기가 결정 |
| DATA | 전역변수 | CompileTime에 크기가 결정 |
| BSS | 전역변수 | CompileTime에 크기가 결정 |
| HEAP | 동적 할당 | RunTime에 크기가 결정 |
| STACK | 지역변수  | RunTime에 크기가 결정 |
- **Code Segment**: 프로그램 소스 코드를 저장
- **Data Segment**: Global 변수, Static 변수, Array, Structure 등 저장. 이곳에는 초기화된 데이터가 저장됨.
- **BSS:** 변수중에 중 초기화 되지 않은 데이터들은 여기에 저장됨
- ****************************HEAP Segment:**************************** 가변 크기를 가지는 구조로 프로그래머가 필요에 따라 할당하여 사용할 수 있는 공간
- ****************************STACK Segment:**************************** 가변 크기로 지역변수가 저장됨  ********************************************************

**STACK Segment 내의 Stack Frame**

어셈블리 프로그래밍을 할 때 서브루틴을 구현하려면 보통 레지스터를 쓴다.

메모리를 복사하는 루틴을 만들고, 복사할 시작 주소, 타겟 주소, 복사할 양으르 서브루틴에 전달한 뒤에, 루틴이 끝나면 다시 호출된 지점으로 돌아와 작업을 계속하는 식이다.

서브루틴이 실행되는 동안 RX 레지스터(값 하나만 저장 가능)에 복귀 주소를 저장하고, 그 값으로 돌아오게 된다.

(메모리 구조 참고: [https://foxtrotin.tistory.com/167](https://foxtrotin.tistory.com/167)서브루틴의 개념 참고: [foxtrotin.tistory.com/170](http://foxtrotin.tistory.com/170))

그런데 문제는, 함수를 한 번만 호출하지는 않는다는 점이다.

함수마다 레지스터를 쓰는데 함수가 중첩되어 실행되기 시작하면 이 함수가 어떤 레지스터를 건들면 안 되는지도 알 수가 없어진다.

그래서 이걸 해결하기 위해, 복귀 주소를 특정 레지스터나 특정 메모리 주소에 저장하지 않고, 스택 공간에 차례대로 쌓는 개념이 등장했다.

그리고 이렇게 복귀 주소를 쌓아둔 스택 메모리 중 가장 윗 부분 주소만 특정 레지스터에 저장하기로 약속했다.

이 특정 레지스터가 바로 SP=스택 포인터고, SP는 스택 프레임을 가리킨다.

복귀 주소를 그렇게 저장하게 되면서 한 번 함수를 호출할 때마다 필요한 메모리 블록도 여러 개가 필요하게 되었다.

그래서 나온 게 **스택 프레임**이고, 함수 호출 시 할당되는 메모리 블록을 의미한다.

**Stack Frame**

---

**RET** → 특정 함수가 끝난 이후에 돌아갈 주소를 의미

**RBP** → Stack이 시작하는 베이스 포인터

RBP 위에 변수들이 들어감

**Stack Frame**
| Stack |  Address | Pointer |
| --- | --- | --- |
| RET | High Addr |  |
| RBP |  | ← %RBP  |
| Variables |  |  |
| Buffer | Low Addr | ← %RSP |

새로운 함수가 Stack Frame에 할당되는 과정

1. RSP 값을 함수가 필요한 공간만큼 늘려줌. 

(e.g) subq 0x10 %rsp

rsp 레지스터에서 16을 빼주면 실제로 Stack Top 값이 기존의 가리키고 있던 메모리 주소 보다 16만큼 낮은 위치를 가리키게  됨.

그런데 Memory Stack은 Down Growth 하기 때문에 스택 주소가 낮아졌다는 것은 스택 공간이 그만큼 늘어났다는 것을 의미함.

따라서 스택 포인터에서 값을 뺀다는 것은 스택의 공간을 늘려주는 것을 의미.
